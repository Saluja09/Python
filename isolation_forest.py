# -*- coding: utf-8 -*-
"""Isolation Forest.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1v7QNARtYzJ7yG-nPEFbKD7kYLLVQdFOI
"""

import numpy as np

class IsolationTree:
    def __init__(self, height_limit):
        # The maximum depth the tree can grow to
        self.height_limit = height_limit

        # The feature and value to split data on
        self.split_feature = None
        self.split_value = None

        # Left and right children of the node
        self.left = None
        self.right = None

        # Data size and depth of current node
        self.size = 0
        self.depth = 0

        # Count of external nodes
        self.exnodes = 1

    def fit(self, X):
        """
        Recursively splits the data on a randomly chosen feature and a randomly chosen split value.
        """
        self.size = len(X)

        # Stop growing the tree if data is too small or tree depth exceeds height_limit
        if len(X) <= 1 or self.depth >= self.height_limit:
            return self

        self.split_feature = np.random.choice(X.shape[1])
        min_value, max_value = np.min(X[:, self.split_feature]), np.max(X[:, self.split_feature])

        # Return if no split can be made
        if min_value == max_value:
            return self

        self.split_value = np.random.uniform(min_value, max_value)

        # Split data and grow left and right children
        left_mask = X[:, self.split_feature] < self.split_value
        self.left = IsolationTree(self.height_limit)
        self.left.depth = self.depth + 1
        self.left.fit(X[left_mask])

        right_mask = ~left_mask
        self.right = IsolationTree(self.height_limit)
        self.right.depth = self.depth + 1
        self.right.fit(X[right_mask])

        return self

    def path_length(self, X):
        """
        Calculate the path length for data points in X. This is essentially the depth at which the data point gets isolated.
        """
        # If external node, return the depth
        if self.left is None and self.right is None:
            return np.array([self.depth] * len(X))

        # Recursively compute path length for child nodes
        left_mask = X[:, self.split_feature] < self.split_value
        right_mask = ~left_mask

        left_lengths = self.left.path_length(X[left_mask])
        right_lengths = self.right.path_length(X[right_mask])

        return np.concatenate([left_lengths, right_lengths])

class IsolationForest:
    def __init__(self, n_estimators=100, max_samples=256):
        # Number of trees in the forest and maximum samples for building each tree
        self.n_estimators = n_estimators
        self.max_samples = max_samples

        # List to store individual trees
        self.trees = []

    def fit(self, X):
        """
        Build the Isolation Forest by constructing multiple isolation trees.
        """
        self.trees = []
        height_limit = np.ceil(np.log2(self.max_samples))
        for i in range(self.n_estimators):
            subset = X[np.random.choice(len(X), self.max_samples, replace=False)]
            tree = IsolationTree(height_limit)
            tree.fit(subset)
            self.trees.append(tree)

    def anomaly_score(self, X):
        """
        Compute the anomaly score for data points in X. A higher score indicates that the data point is more anomalous.
        """
        path_lengths = np.array([tree.path_length(X) for tree in self.trees])
        avg_path_length = np.mean(path_lengths, axis=0)
        return 2.0 ** (-avg_path_length / self._c(len(X)))

    def _c(self, size):
        """
        Average path length of unsuccessful search in a BST given n nodes.
        """
        if size > 2:
            return 2.0 * (np.log(size - 1) + 0.5772156649) - 2.0 * (size - 1) / size
        if size == 2:
            return 1.0
        return 0

# Example usage:

from sklearn.datasets import make_moons
import matplotlib.pyplot as plt

# Generate a 2D dataset with two moon-shaped clusters
X, _ = make_moons(n_samples=300, noise=0.05, random_state=42)

forest = IsolationForest()
forest.fit(X)

# Score the anomaly of each data point
scores = forest.anomaly_score(X)

# Visualize the data points with colors representing their anomaly scores
plt.scatter(X[:, 0], X[:, 1], s=50, c=scores, cmap='viridis')
plt.colorbar()
plt.show()